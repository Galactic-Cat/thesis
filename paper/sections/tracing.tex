\section{Tracing}
    In the broadest terms, when we trace a program, we track the most basic steps the program takes provided some input.
    This is relevant for many applications in Computer Science.
    Certain automatic differentiation (AD) effectively implement the forward-pass as tracing, and then perform the reverse pass on the trace\cn.
    Tracing is also used to speed up program execution by making assumptions on the program's execution path from the trace\cn.
    \cc{Another example? Rule of threes!}

    However, despite its ambivalence, tracing is rarely properly defined, or defined only for a specific use case.
    So, in this section we will set out to create a more general definition of tracing.
    
    To start, it will help us along to set clear expectations for what we expect a tracing function to do.
    In the simplest terms, we expect a tracing program to take an input program with a set of inputs, and output a ``trace''.
    This output trace is generally defined as a set of operations the input program performed on the inputs.
    A term often used for an output trace is a ``single-line program''\cn: a program without control flow.
    Clearing control flow like if-then-else statements is only natural: after all, provided some input the program will only walk down one variation of this branching path.

    Furthermore, it is also generally accepted that the trace consists of a subset of the syntax of the input program.
    Because we're generally more interested in what happens to the data in our program, we can ``trace away'' functions and data structures.
    More precisely, say our input program has the types as defined in Equation \ref{eq:typebase}, where we have sum-types as $\tau+\sigma$, product types as $\tau\times\sigma$, functions as $\tau\to\sigma$, literal real numbers, and literal Booleans.

    \begin{equation}
        \label{eq:typebase}
        \tau,\sigma\coloneqq\tau+\sigma\|\tau\times\sigma\|\tau\to\sigma\|\mathbb{R}\|\mathbb{B}
    \end{equation}

    We can imagine our simplified language, in which we will express our trace -- as a language with less types.
    By choosing a subset of the types in our program, we can indicate which data structures should be traced away.
    A common option is to keep only ``grounded types'', where we defined a grounded type as a type that isn't constructed of other types.
    Looking at our example in Equation \ref{eq:typebase}, a trace keeping only these grounded types would keep only the real numbers and the Booleans as they are not built of other types.
    Another common option is to keep only continuous types, tracing away all ungrounded and discrete types.
    Doing that on our type set in Equation \ref{eq:typebase} would leave us with only the real numbers.
    This is under the assumption that the discrete types aren't actually used as data we're interested in tracing of course, but since tracing will remove all control flow from the program, keeping Booleans and operations on Booleans intact may be meaningless. 

    The main take-away here is that there is some freedom of choice in what to trace away.
    What parts we keep and what parts we trace away is very dependent on what information we want to keep in our trace.
    Which in turn is dependent on what our exact goal is for the tracing in the first place.
    
    We can also choose to keep some of our ungrounded types, but then we run into a problem.
    Say we keep only functions ($\tau\to\sigma$) and real numbers, but our input program contains a function with type $\tau\to(\sigma_1+\sigma_2)$.
    This typing is valid in our input program, but no longer valid in our trace, so we find ourselves in a bind.
    It will be impossible to trace away the sum-type in the output of the function without tracing away the function itself.
    \cc{Why exactly?}
    Of course we could define a subset $\tau',\sigma'\coloneqq\mathbb{R}$ and then redefine (or add a definition for) our function so that it becomes $\tau'\to\sigma'$ making it safe to trace.
    This then underlines the rule at work here: we can only keep types that do cannot be constructed of types that are traced away.
    This is why the grounded types are a natural set of types to keep, as they are never constructed from other types.
    In a similar vein, although slightly less clear, we also trace away any operators that perform on or produce types that we do not keep in our trace.
    For example, when we choose to keep only real numbers, we can trace away all Boolean values and operations that take in or produce Boolean values.
    After all, they will be meaningless in our limited trace language.
    This ``tracing away'' often comes down to rewriting or omitting these operations in the trace.
    For operations that influence control flow this is simple, however if we have types that we wish to trace away in some data that we use or (more importantly) combine with types that we do wish to keep, omission might mean our trace is missing steps.
    We might be able to express these types we trace away as types we keep, if they are necessary, but this might be more work than it is worth.

    It seems that our tracing definition comes down to a function that takes in a program and an input to that program, and outputs the steps taken by the program run on the input.
    Where the input program takes uses some set of types, of which only a subset is kept in the trace, where the types in this subset may not be constructed using types from outside of the subset.

    What now remains is a concrete definition of the output of the tracing program.
    We have already stated that it should somehow contain the steps done in by the input program.
    The steps we wish to record are generally basic operations like arithmetic operations.
    But other operations, such as operations on arrays, can also be added depending on the ultimate goal of the tracing.
    More importantly, as we expect our trace to be akin to a single-line program, we may consider our trace as a series of let-bindings, akin to A-normal form\cn.
    
    % Implementation wise, we might produce our trace as a set of 2-tuples, consisting of a name and the actual operation.
    % As long as every component is properly named, every operation in the trace can actually just refer to a previous point in the trace, except for new data.
    % This way, we can get away with only storing the operation themselves, and not their inputs or results.
    % Because of this implementation method, we will assume our trace to be of the type $\{(\text{String},\text{Operation})\}$.
    % This will allow us the freedom to add to the trace as in taking the union of two sets: the current trace, and any items to add to it.
    
    Finally, we can quickly check if our trace is correct by executing both the input program and the trace, and checking if their results are the same.
    We can also check the correctness of our tracing program by running it with a trace as its input program.
    Tracing a trace should return the trace itself, because if it returned some more minimal trace, we know that the first trace wasn't properly finished.
    \cc{This probably needs a more precise description.}

    \subsection{Tracing Steps} \label{sec:steps}
        \cc{Should maybe add an eval function to make it clearer when things are actually resolved}\\
        We will now define some basic tracing steps for some arbitrary language.
        To do this we first define a language on which we will operate.
        We do this in Listing \ref{lst:language}, where we define a basic lambda calculus.

        \begin{lstlisting}[caption=Basic language, captionpos=b, float=tbhp, label=lst:language, mathescape, escapeinside={!*}{*!}, gobble=12]
            !*\textbf{Types:}*!
                $\sigma,\tau\coloneqq\mathbb{R}\|\sigma\to\tau$

            !*\textbf{Terms:}*!
                $s,t\coloneqq$
                    $r\in\mathbb{R}\quad$!*\text{(literal real numbers)}*!
                  | $\lambda(x:\tau).s\quad$!*\text{(abstraction)}*!
                  | $s\ t\quad$!*\text{(application)}*!
        \end{lstlisting}

        Tracing through this lambda calculus is pretty straightforward.
        We will define our trace as some set $T$, such that our tracing function $\text{trace}(\Gamma,e)\to(v,T)$ gives us a value $v$ and a trace $T$ for some environment $\Gamma$ and some expression $e$.
        To not go into too much implementational overhead, we will ignore naming the items in the trace for now.
        Listing \ref{lst:tracing} shows how tracing the lambda calculus in Listing \ref{lst:language} would look like, if we choose to trace away the function type (leaving us only with real numbers).
        We see that tracing a literal real number $r$, just adds $r$ to the trace, after all real numbers aren't traced away.
        Tracing application is also fairly straightforward: we trace the argument $t$, and then the function $s$ with $t$.
        Only our $\lambda$-abstraction is a little more complex.
        Since nothing actually happens our trace here is empty, however this does not mean that we can ignore the steps the abstracted expression takes, those we might still be interested in.
        So we can rewrite the lambda expression, to move the trace over, and trace only the body when it is actually applied.
        This also has as a side-effect on application, that we call the result of the trace of $s$ as a function, as that will be the rewritten lambda expression we got from tracing abstraction.

        \begin{lstlisting}[caption=First tracing rules, captionpos=b, float=tbhp, label=lst:tracing, mathescape, escapeinside={!*}{*!}, gobble=12]
            $\text{trace}(\Gamma,n\in\mathbb{R})\Rightarrow(r, \{r\})$
            $\text{trace}(\Gamma,\lambda(x:\tau).s)\Rightarrow(\lambda(x:\tau).trace(\Gamma\cup x, s),\emptyset)$
            $\text{trace}(\Gamma,s\ t)\Rightarrow(s\ t,\text{trace}(\Gamma, s)(\text{trace}(\Gamma,t)))$
        \end{lstlisting}

        It should be noted that tracing abstraction and application this way, effectively traces away function types.
        This is generally what we want from a trace, but it is somewhat meaningful to realize what would happen if we chose not to do that.
        In that case, we no longer deconstruct functions, so our trace on abstraction becomes similar to our trace on real numbers: we just return the function as we found it.
        As for application, we can no longer trace the body of our function, so all that remains in tracing its argument and perhaps denoting the application took place.

        Now to illustrate how tracing would eliminate control-flow, we would first need to add some to our language.
        We can extend our language in Listing \ref{lst:language} with an if-then-else statement, as shown in Listing \ref{lst:language_bools}.
        To make it easy on ourselves, we also add Booleans to the language as the domain $\mathbb{B}=\{\top,\bot\}$.
        However, we maintain, that we only want to trace to contain real numbers as a type, so this means we need to trace away these Booleans, and any operations performed on them.
        Which brings us to the following point: there are no operations in our language.
        Whilst we can validate our if-then-else statement with literal Booleans, it is probably more meaningful to actually add operations to the language.
        To keep things general, we will denote these operations as $Op_\mathbb{X}(s_1,\dots,s_n):\mathbb{Y}$, where $\mathbb{X}$ is the domain of the $n$ inputs $s_1,\dots,s_n$, and $\mathbb{Y}$ is the codomain of the operation.
        To keep things simple, we will assume for now that $Op:\mathbb{X}^n\to\mathbb{Y}$ for any domain $\mathbb{X}$ and codomain $\mathbb{Y}$.
        In Listing \ref{lst:language_bool}, we define three domain-codomain pairs for basic operators: $\mathbb{B}\to\mathbb{B}$ for comparing Booleans, $\mathbb{R}\to\mathbb{B}$ for comparing real numbers, and $\mathbb{R}\to\mathbb{R}$ for arithmetic operators.
        These three categories encapsulate the vast majority of what are considered ``basic operations''.

        \begin{lstlisting}[caption=Booleans and operations in the language, captionpos=b, float=tbhp, label=lst:language_bools, mathescape, escapeinside={!*}{*!}, gobble=12]
            !*\textbf{Types:}*!
                $\sigma,\tau\coloneqq\mathbb{B}\|\mathbb{R}\|\sigma\to\tau$

            !*\textbf{Terms:}*!
                $s,t\coloneqq$
                    $\dots$
                  | $\texttt{if }s:\mathbb{B}\texttt{ then }t_\top:\tau\texttt{ else }t_\bot:\tau$
                  | $Op_\mathbb{B}(s_1,\dots,s_n):\mathbb{B}$
                  | $Op_\mathbb{R}(s_1,\dots,s_n):\mathbb{B}$
                  | $Op_\mathbb{R}(s_1,\dots,s_n):\mathbb{R}$
        \end{lstlisting}

        With our language expanded, we can now trace away our control flow.
        The resulting cases are shown in Listing \ref{lst:tracing_bool}.
        It should be noted that even though we do not trace away basic operations in general, we can (and in fact have to) trace away operations either on Booleans, or producing Booleans, as we have no Boolean type in our trace.
        This effectively also means, that if we have some operations on real numbers, that only result in eventually producing some Boolean, these operations are omitted from the trace as well.
        If this seems odd, we must remind ourselves that the trace we produce can be interpreted as a ``single-line program'', and any part of the program that only exists to produce values that are irrelevant to the single-line program, should not be in the trace.
        It should also be noted that if we'd want to keep Booleans in our trace for some reason, this would still allow us to trace away control-flow, like the if-then-else statements, as they would still be irrelevant for the single-line program.
        However, what to do with the steps leading up to these would become a little more unclear.
        If the Booleans used by the if-then-else statements in our program are either part of the input or output of the program, they should probably also be present in the trace.
        However, if they are not, then they should probably still be discarded as being irrelevant to the single-line program.

        \begin{lstlisting}[caption=Control flow tracing, captionpos=b, float=tbhp, label=lst:tracing_bool, mathescape, escapeinside={!*}{*!}, gobble=12]
            $\text{trace}(\Gamma,\texttt{if }s\texttt{ then }t_\top\texttt{ else }t_\bot)\Rightarrow\texttt{if }s\texttt{ then }\text{trace}(\Gamma,t_\top)\texttt{ else }\text{trace}(\Gamma,t_\bot)$
            $\text{trace}(\Gamma,Op_\mathbb{B}(e_1,\dots,e_n):\mathbb{B})\Rightarrow(Op_\mathbb{B}(e_1,\dots,e_n):\mathbb{B},\emptyset)
            $\text{trace}(\Gamma,Op_\mathbb{R}(e_1,\dots,e_n):\mathbb{B})\Rightarrow(Op_\mathbb{R}(e_1,\dots,e_n):\mathbb{B},\emptyset)
            $\text{trace}(\Gamma,Op_\mathbb{R}(e_1,\dots,e_n):\mathbb{R})\Rightarrow(Op_\mathbb{R}(e_1,\dots,e_n):\mathbb{R},\{Op_\mathbb{R}(e_1,\dots,e_n):\mathbb{R}\}\cup\text{trace}(\Gamma,e_1)\cup\dots\cup\text{trace}(\Gamma,e_n))$
        \end{lstlisting}

        Finally, we'd like to take a quick look at let-bindings.
        In general let-bindings are can be treated as lambda abstractions that are instantly applied.
        This allows us to streamline them a little more than we were able to with regular lambda abstractions in Listing \ref{lst:tracing}.
        So, we can add let-bindings to our language in Listing \ref{lst:language_let}, and their trace in Listing \ref{lst:tracing_let}.

        \begin{lstlisting}[caption=Adding let bindings, captionpos=b, float=tbhp, label=lst:language_let, mathescape, escapeinside={!*}{*!}, gobble=12]
            !*\textbf{Types: }*!$\dots$

            !*\textbf{Terms:}*!
                $s,t\coloneqq$
                    $\dots$
                  | $\texttt{let }s:\sigma\texttt{ in }t:\tau$
        \end{lstlisting}

        \begin{lstlisting}[caption=Tracing let bindings, captionpos=b, float=tbhp, label=lst:language_let, mathescape, escapeinside={!*}{*!}, gobble=12]
            $\text{trace}(\Gamma,\texttt{let }s\texttt{ in }t)\Rightarrow(\texttt{let }s\texttt{ in }t,\texttt{trace}(\Gamma,s)\cup\texttt{trace}(\Gamma\cup\{s\},t))$
        \end{lstlisting}

    \subsection{Array Tracing}
        An important part of programming, including the programs where tracing is likely to be used, is arrays and other data structures.
        Tracing data structures like arrays might seem a little more complicated, however the main is whether or not we want to trace away arrays.
        For our upcoming example, we first add Arrays to our language from Section \ref{sec:steps} (Listings \ref{lst:language}, \ref{lst:language_bools}, and \ref{lst:language_let}), as shown in Listing \ref{lst:language_array}.
        For now, we will limit our discussion to arrays of real numbers only.
        We will also operations on arrays, currently just as the operations producing a single value from the array, like indexing or sum ($[\mathbb{R}]\to\mathbb{R}$), and those that produce a new array like mapping a function ($[\mathbb{R}]\to[\mathbb{R}]$).

        \begin{lstlisting}[caption=Adding arrays, captionpos=b, float=tbhp, label=lst:language_array, mathescape, escapeinside={!*}{*!}, gobble=12]
            !*\textbf{Types: }*!
                $\sigma,\tau\coloneqq\mathbb{B}\|\mathbb{R}\|\sigma\to\tau\|[\mathbb{R}]$

            !*\textbf{Terms:}*!
                $s,t\coloneqq$
                    $\dots$
                  | $[s_1:\mathbb{R},\dots,s_n:\mathbb{R}]$
                  | $Op_{[\mathbb{R}]}(s):\mathbb{R}$
                  | $Op_{[\mathbb{R}]}(s):[\mathbb{R}]$
        \end{lstlisting}
        
        If we were to extend our example from Section \ref{sec:steps}, we might be inclined to not allow arrays in our trace (and keep only real numbers), meaning we would have to trace the arrays away.
        This isn't too complicated.
        When tracing away arrays as terms, we might break them down into their component parts.
        For instance, an array of real numbers, can be traced as just the instantiation of every real number in the array.
        The same goes for operations done to the array: we just trace these operations as they are applied to the individual items in the array, effectively ignoring the fact that these items were in an array in the first place.

        