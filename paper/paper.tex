\documentclass{paper}

\usepackage{adjustbox}
\usepackage{appendix}
\usepackage[english]{babel}
\usepackage{etoolbox}
\usepackage{framed}
\usepackage{hyperref}
\usepackage{amsmath, amssymb}
\usepackage[a4paper,margin=1.5in]{geometry}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{multicol}
\usepackage{wrapfig}
\usepackage[x11names]{xcolor}
\usepackage{listings}
\usepackage{mathtools}
\usepackage[x11names]{xcolor}

\hypersetup{
    colorlinks,
    linkcolor={green!50!black},
    citecolor={cyan!50!black},
    urlcolor={blue!80!black}
}

\setlength{\parskip}{1em}
\setlength{\parindent}{0pt}

\newcommand{\cn}{\textsuperscript{\color{red}[cite me]}}
\newcommand{\cc}[1]{{\color{cyan}#1}}
\newcommand{\df}{\coloneqq}
\renewcommand{\|}{\ |\ }
\newcommand{\tran}{^{\mkern-1.5mu\mathsf{T}}}

\lstnewenvironment{quicklst}[1][]
    {\lstset{float=tbhp,frame=single,captionpos=b,mathescape=true,escapeinside={!*}{*!},moredelim=**[is][\color{red}]{@r}{@},#1}}
    {}

\lstnewenvironment{haskell}[1][]
    {\lstset{
        float=tbhp,
        frame=single,
        captionpos=b,
        columns=fullflexible,
        language=haskell,
        mathescape=true,
        escapeinside={!*}{*!},
        keywordstyle=\color{Blue4}\bfseries,
        basicstyle=\small\ttfamily,
        commentstyle=\footnotesize\color{Green4}\normalfont\itshape,
        keepspaces=true,
        showstringspaces=false,
        numbers=left,
        numberstyle=\tiny,
        #1}}
    {}

\title{Maintaining parallelism in reverse-mode automatic differentiation on functional parallel array languages}
\author{Simon van Hus\\6147879\\s.vanhus@students.uu.nl}
\date{\today}

\begin{document}
    \maketitle

    \begin{abstract}
        In this paper we set out to make a simple reverse-mode automatic differentiation (AD) algorithm, that uses tracing for the forward pass, and preserves data parallelism in the reverse pass.
        To do this, we first try to formalize the notion of tracing somewhat.
        We find that while some flexibility in the definition of is needed for it to work well, we can also boil it down to picking a subset of data types to keep in the trace.
        We also define a couple of logical assertions that further help us in showing whether a trace does really contain the information that we need.
        Having defined tracing, in theory, but also over a Haskell DSL, we continue to automatic differentiation.
        Here we expand the tracing function into a forward-pass function by adding reference counting and intermediate values.
        Using this forward-pass trace as a map, we then show how we can do the reverse-pass.
        We also show that we can keep data-parallelism intact for the map and fold (reduce) operations.
        Finally, we also highlight how task parallelism can be used in the reverse-pass to possibly unlock even more efficiency.
    \end{abstract}

    \input{sections/background}

    \input{sections/tracing}

    \input{sections/reverse}

    \input{sections/conclusion}

    \clearpage
    \bibliographystyle{unsrt}
    \bibliography{references}
    \clearpage
    \appendix
    \input{sections/eval}
\end{document}